

## FINGER：

- 观察出结论：大多数距离计算对更好的搜索结果没有产生贡献。（启发式算法）
也就是说，可以设置一个距离上界，当搜索的距离超过这个上界，则不参与计算。（剪枝）可以采用近似计算来减少计算量。


计算最近点的算法（算法1，即贪心算法）：
- 给定图G，一个询问点q，起始点p，求dist的函数以及邻域的数量。
- 终止循环条件：当前访问点到点$q$的距离超过了结果集合中的最远距离。
- 对于每个bfs更新的当前点而言，将这部分点的邻域加入比较。如果有更好的结果或者结果集合没有满，则加入优先队列。
- 同时，每次寻找完更新点，保证结果集T的大小不超过一个特定值。

给定问题：

给出一个询问点$q$，以及一个中心点$c$。对于一个$c$的特定的最近点集$d$，我们通过计算$q$和$d$的距离来更新查找的results。

采用L2距离。一个想法是可以把$c$进行正交分解。最后可以分解成一个正交和一个投影方向的向量。

由此可以得到：

$q = q_{proj} + q_{res},q_{proj} = \frac{c^Tq}{c^Tc}c,q_{res}=q-q_{proj}$

由此L2距离可以写成：

$|Dist|^2 = ||q - d||_2^2 = ||(q_{proj} - d_{proj})+(q_{res}-d_{res})||^2_2=||(q_{proj} - d_{proj})||^2_2 + ||(q_{res}-d_{res})||^2_2 = ||q_{proj}||^2_2 + ||d_{res}||^2_2 - 2q^T_{res}d_{res}$

$d_{proj}$和$d_{res}$在建图的时候就可以得到了；$||q-c||_2$在搜索算法运行的时候就已经被计算过了。因此可以通过一个计算得到$q^Tc$:

$q^Tc = \frac{||q|^2 + ||c||^2_2 - ||q-c||^2_2}{2}$

由此$q_{proj}$可以计算得到。唯一的未知项便是$q_{res}^Td_{res}$。需要设计一个近似量来模拟$cos(q_{res},d_{res})$。

当q和d的距离小于一个阈值时，可以认为q和d是近的。此时我们只需要考虑d中的点满足的关系。（也就是q的邻域中的cos值满足的关系）此时，d中向量的cos值会服从一个高斯分布。我们由此可以设计一个算法来满足这个模拟。

#### FINGER

使用位置敏感哈希及其变体来实现对正态分布中随机采样的近似。


尝试复现FINGER以及DISKANN算法

todo 
Product Quantization
HNSW建图
